{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bottom = bottom;\nexports.childrenEqual = childrenEqual;\nexports.cloneLayout = cloneLayout;\nexports.cloneLayoutItem = cloneLayoutItem;\nexports.collides = collides;\nexports.compact = compact;\nexports.compactItem = compactItem;\nexports.compactType = compactType;\nexports.correctBounds = correctBounds;\nexports.fastPositionEqual = fastPositionEqual;\nexports.fastRGLPropsEqual = void 0;\nexports.getAllCollisions = getAllCollisions;\nexports.getFirstCollision = getFirstCollision;\nexports.getLayoutItem = getLayoutItem;\nexports.getStatics = getStatics;\nexports.modifyLayout = modifyLayout;\nexports.moveElement = moveElement;\nexports.moveElementAwayFromCollision = moveElementAwayFromCollision;\nexports.noop = void 0;\nexports.perc = perc;\nexports.setTopLeft = setTopLeft;\nexports.setTransform = setTransform;\nexports.sortLayoutItems = sortLayoutItems;\nexports.sortLayoutItemsByColRow = sortLayoutItemsByColRow;\nexports.sortLayoutItemsByRowCol = sortLayoutItemsByRowCol;\nexports.synchronizeLayoutWithChildren = synchronizeLayoutWithChildren;\nexports.validateLayout = validateLayout;\nexports.withLayoutItem = withLayoutItem;\n\nvar _lodash = _interopRequireDefault(require(\"lodash.isequal\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar isProduction = process.env.NODE_ENV === \"production\";\nvar DEBUG = false;\n/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\n\nfunction bottom(layout\n/*: Layout*/\n)\n/*: number*/\n{\n  var max = 0,\n      bottomY;\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    bottomY = layout[i].y + layout[i].h;\n    if (bottomY > max) max = bottomY;\n  }\n\n  return max;\n}\n\nfunction cloneLayout(layout\n/*: Layout*/\n)\n/*: Layout*/\n{\n  var newLayout = Array(layout.length);\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    newLayout[i] = cloneLayoutItem(layout[i]);\n  }\n\n  return newLayout;\n} // Modify a layoutItem inside a layout. Returns a new Layout,\n// does not mutate. Carries over all other LayoutItems unmodified.\n\n\nfunction modifyLayout(layout\n/*: Layout*/\n, layoutItem\n/*: LayoutItem*/\n)\n/*: Layout*/\n{\n  var newLayout = Array(layout.length);\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (layoutItem.i === layout[i].i) {\n      newLayout[i] = layoutItem;\n    } else {\n      newLayout[i] = layout[i];\n    }\n  }\n\n  return newLayout;\n} // Function to be called to modify a layout item.\n// Does defensive clones to ensure the layout is not modified.\n\n\nfunction withLayoutItem(layout\n/*: Layout*/\n, itemKey\n/*: string*/\n, cb\n/*: LayoutItem => LayoutItem*/\n)\n/*: [Layout, ?LayoutItem]*/\n{\n  var item = getLayoutItem(layout, itemKey);\n  if (!item) return [layout, null];\n  item = cb(cloneLayoutItem(item)); // defensive clone then modify\n  // FIXME could do this faster if we already knew the index\n\n  layout = modifyLayout(layout, item);\n  return [layout, item];\n} // Fast path to cloning, since this is monomorphic\n\n\nfunction cloneLayoutItem(layoutItem\n/*: LayoutItem*/\n)\n/*: LayoutItem*/\n{\n  return {\n    w: layoutItem.w,\n    h: layoutItem.h,\n    x: layoutItem.x,\n    y: layoutItem.y,\n    i: layoutItem.i,\n    minW: layoutItem.minW,\n    maxW: layoutItem.maxW,\n    minH: layoutItem.minH,\n    maxH: layoutItem.maxH,\n    moved: Boolean(layoutItem.moved),\n    static: Boolean(layoutItem.static),\n    // These can be null/undefined\n    isDraggable: layoutItem.isDraggable,\n    isResizable: layoutItem.isResizable,\n    resizeHandles: layoutItem.resizeHandles,\n    isBounded: layoutItem.isBounded\n  };\n}\n/**\n * Comparing React `children` is a bit difficult. This is a good way to compare them.\n * This will catch differences in keys, order, and length.\n */\n\n\nfunction childrenEqual(a\n/*: ReactChildren*/\n, b\n/*: ReactChildren*/\n)\n/*: boolean*/\n{\n  return (0, _lodash.default)(_react.default.Children.map(a, function (c) {\n    return c === null || c === void 0 ? void 0 : c.key;\n  }), _react.default.Children.map(b, function (c) {\n    return c === null || c === void 0 ? void 0 : c.key;\n  }));\n}\n/**\n * See `fastRGLPropsEqual.js`.\n * We want this to run as fast as possible - it is called often - and to be\n * resilient to new props that we add. So rather than call lodash.isEqual,\n * which isn't suited to comparing props very well, we use this specialized\n * function in conjunction with preval to generate the fastest possible comparison\n * function, tuned for exactly our props.\n */\n\n/*:: type FastRGLPropsEqual = (Object, Object, Function) => boolean;*/\n\n\nvar fastRGLPropsEqual\n/*: FastRGLPropsEqual*/\n= require(\"./fastRGLPropsEqual\"); // Like the above, but a lot simpler.\n\n\nexports.fastRGLPropsEqual = fastRGLPropsEqual;\n\nfunction fastPositionEqual(a\n/*: Position*/\n, b\n/*: Position*/\n)\n/*: boolean*/\n{\n  return a.left === b.left && a.top === b.top && a.width === b.width && a.height === b.height;\n}\n/**\n * Given two layoutitems, check if they collide.\n */\n\n\nfunction collides(l1\n/*: LayoutItem*/\n, l2\n/*: LayoutItem*/\n)\n/*: boolean*/\n{\n  if (l1.i === l2.i) return false; // same element\n\n  if (l1.x + l1.w <= l2.x) return false; // l1 is left of l2\n\n  if (l1.x >= l2.x + l2.w) return false; // l1 is right of l2\n\n  if (l1.y + l1.h <= l2.y) return false; // l1 is above l2\n\n  if (l1.y >= l2.y + l2.h) return false; // l1 is below l2\n\n  return true; // boxes overlap\n}\n/**\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\n * between items.\n *\n * Does not modify layout items (clones). Creates a new layout array.\n *\n * @param  {Array} layout Layout.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return {Array}       Compacted Layout.\n */\n\n\nfunction compact(layout\n/*: Layout*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n)\n/*: Layout*/\n{\n  // Statics go in the compareWith array right away so items flow around them.\n  var compareWith = getStatics(layout); // We go through the items by row and column.\n\n  var sorted = sortLayoutItems(layout, compactType); // Holding for new items.\n\n  var out = Array(layout.length);\n\n  for (var i = 0, len = sorted.length; i < len; i++) {\n    var l = cloneLayoutItem(sorted[i]); // Don't move static elements\n\n    if (!l.static) {\n      l = compactItem(compareWith, l, compactType, cols, sorted); // Add to comparison array. We only collide with items before this one.\n      // Statics are already in this array.\n\n      compareWith.push(l);\n    } // Add to output array to make sure they still come out in the right order.\n\n\n    out[layout.indexOf(sorted[i])] = l; // Clear moved flag, if it exists.\n\n    l.moved = false;\n  }\n\n  return out;\n}\n\nvar heightWidth = {\n  x: \"w\",\n  y: \"h\"\n};\n/**\n * Before moving item down, it will check if the movement will cause collisions and move those items down before.\n */\n\nfunction resolveCompactionCollision(layout\n/*: Layout*/\n, item\n/*: LayoutItem*/\n, moveToCoord\n/*: number*/\n, axis\n/*: \"x\" | \"y\"*/\n) {\n  var sizeProp = heightWidth[axis];\n  item[axis] += 1;\n  var itemIndex = layout.map(function (layoutItem) {\n    return layoutItem.i;\n  }).indexOf(item.i); // Go through each item we collide with.\n\n  for (var i = itemIndex + 1; i < layout.length; i++) {\n    var otherItem = layout[i]; // Ignore static items\n\n    if (otherItem.static) continue; // Optimization: we can break early if we know we're past this el\n    // We can do this b/c it's a sorted layout\n\n    if (otherItem.y > item.y + item.h) break;\n\n    if (collides(item, otherItem)) {\n      resolveCompactionCollision(layout, otherItem, moveToCoord + item[sizeProp], axis);\n    }\n  }\n\n  item[axis] = moveToCoord;\n}\n/**\n * Compact an item in the layout.\n *\n * Modifies item.\n *\n */\n\n\nfunction compactItem(compareWith\n/*: Layout*/\n, l\n/*: LayoutItem*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n, fullLayout\n/*: Layout*/\n)\n/*: LayoutItem*/\n{\n  var compactV = compactType === \"vertical\";\n  var compactH = compactType === \"horizontal\";\n\n  if (compactV) {\n    // Bottom 'y' possible is the bottom of the layout.\n    // This allows you to do nice stuff like specify {y: Infinity}\n    // This is here because the layout must be sorted in order to get the correct bottom `y`.\n    l.y = Math.min(bottom(compareWith), l.y); // Move the element up as far as it can go without colliding.\n\n    while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n      l.y--;\n    }\n  } else if (compactH) {\n    // Move the element left as far as it can go without colliding.\n    while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n      l.x--;\n    }\n  } // Move it down, and keep moving it down if it's colliding.\n\n\n  var collides;\n\n  while (collides = getFirstCollision(compareWith, l)) {\n    if (compactH) {\n      resolveCompactionCollision(fullLayout, l, collides.x + collides.w, \"x\");\n    } else {\n      resolveCompactionCollision(fullLayout, l, collides.y + collides.h, \"y\");\n    } // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.\n\n\n    if (compactH && l.x + l.w > cols) {\n      l.x = cols - l.w;\n      l.y++;\n    }\n  } // Ensure that there are no negative positions\n\n\n  l.y = Math.max(l.y, 0);\n  l.x = Math.max(l.x, 0);\n  return l;\n}\n/**\n * Given a layout, make sure all elements fit within its bounds.\n *\n * Modifies layout items.\n *\n * @param  {Array} layout Layout array.\n * @param  {Number} bounds Number of columns.\n */\n\n\nfunction correctBounds(layout\n/*: Layout*/\n, bounds\n/*: { cols: number }*/\n)\n/*: Layout*/\n{\n  var collidesWith = getStatics(layout);\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    var l = layout[i]; // Overflows right\n\n    if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w; // Overflows left\n\n    if (l.x < 0) {\n      l.x = 0;\n      l.w = bounds.cols;\n    }\n\n    if (!l.static) collidesWith.push(l);else {\n      // If this is static and collides with other statics, we must move it down.\n      // We have to do something nicer than just letting them overlap.\n      while (getFirstCollision(collidesWith, l)) {\n        l.y++;\n      }\n    }\n  }\n\n  return layout;\n}\n/**\n * Get a layout item by ID. Used so we can override later on if necessary.\n *\n * @param  {Array}  layout Layout array.\n * @param  {String} id     ID\n * @return {LayoutItem}    Item at ID.\n */\n\n\nfunction getLayoutItem(layout\n/*: Layout*/\n, id\n/*: string*/\n)\n/*: ?LayoutItem*/\n{\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (layout[i].i === id) return layout[i];\n  }\n}\n/**\n * Returns the first item this layout collides with.\n * It doesn't appear to matter which order we approach this from, although\n * perhaps that is the wrong thing to do.\n *\n * @param  {Object} layoutItem Layout item.\n * @return {Object|undefined}  A colliding layout item, or undefined.\n */\n\n\nfunction getFirstCollision(layout\n/*: Layout*/\n, layoutItem\n/*: LayoutItem*/\n)\n/*: ?LayoutItem*/\n{\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (collides(layout[i], layoutItem)) return layout[i];\n  }\n}\n\nfunction getAllCollisions(layout\n/*: Layout*/\n, layoutItem\n/*: LayoutItem*/\n)\n/*: Array<LayoutItem>*/\n{\n  return layout.filter(function (l) {\n    return collides(l, layoutItem);\n  });\n}\n/**\n * Get all static elements.\n * @param  {Array} layout Array of layout objects.\n * @return {Array}        Array of static layout items..\n */\n\n\nfunction getStatics(layout\n/*: Layout*/\n)\n/*: Array<LayoutItem>*/\n{\n  return layout.filter(function (l) {\n    return l.static;\n  });\n}\n/**\n * Move an element. Responsible for doing cascading movements of other elements.\n *\n * Modifies layout items.\n *\n * @param  {Array}      layout            Full layout to modify.\n * @param  {LayoutItem} l                 element to move.\n * @param  {Number}     [x]               X position in grid units.\n * @param  {Number}     [y]               Y position in grid units.\n */\n\n\nfunction moveElement(layout\n/*: Layout*/\n, l\n/*: LayoutItem*/\n, x\n/*: ?number*/\n, y\n/*: ?number*/\n, isUserAction\n/*: ?boolean*/\n, preventCollision\n/*: ?boolean*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n, allowOverlap\n/*: ?boolean*/\n)\n/*: Layout*/\n{\n  // If this is static and not explicitly enabled as draggable,\n  // no move is possible, so we can short-circuit this immediately.\n  if (l.static && l.isDraggable !== true) return layout; // Short-circuit if nothing to do.\n\n  if (l.y === y && l.x === x) return layout;\n  log(\"Moving element \".concat(l.i, \" to [\").concat(String(x), \",\").concat(String(y), \"] from [\").concat(l.x, \",\").concat(l.y, \"]\"));\n  var oldX = l.x;\n  var oldY = l.y; // This is quite a bit faster than extending the object\n\n  if (typeof x === \"number\") l.x = x;\n  if (typeof y === \"number\") l.y = y;\n  l.moved = true; // If this collides with anything, move it.\n  // When doing this comparison, we have to sort the items we compare with\n  // to ensure, in the case of multiple collisions, that we're getting the\n  // nearest collision.\n\n  var sorted = sortLayoutItems(layout, compactType);\n  var movingUp = compactType === \"vertical\" && typeof y === \"number\" ? oldY >= y : compactType === \"horizontal\" && typeof x === \"number\" ? oldX >= x : false; // $FlowIgnore acceptable modification of read-only array as it was recently cloned\n\n  if (movingUp) sorted = sorted.reverse();\n  var collisions = getAllCollisions(sorted, l);\n  var hasCollisions = collisions.length > 0; // We may have collisions. We can short-circuit if we've turned off collisions or\n  // allowed overlap.\n\n  if (hasCollisions && allowOverlap) {\n    // Easy, we don't need to resolve collisions. But we *did* change the layout,\n    // so clone it on the way out.\n    return cloneLayout(layout);\n  } else if (hasCollisions && preventCollision) {\n    // If we are preventing collision but not allowing overlap, we need to\n    // revert the position of this element so it goes to where it came from, rather\n    // than the user's desired location.\n    log(\"Collision prevented on \".concat(l.i, \", reverting.\"));\n    l.x = oldX;\n    l.y = oldY;\n    l.moved = false;\n    return layout; // did not change so don't clone\n  } // Move each item that collides away from this element.\n\n\n  for (var i = 0, len = collisions.length; i < len; i++) {\n    var collision = collisions[i];\n    log(\"Resolving collision between \".concat(l.i, \" at [\").concat(l.x, \",\").concat(l.y, \"] and \").concat(collision.i, \" at [\").concat(collision.x, \",\").concat(collision.y, \"]\")); // Short circuit so we can't infinite loop\n\n    if (collision.moved) continue; // Don't move static items - we have to move *this* element away\n\n    if (collision.static) {\n      layout = moveElementAwayFromCollision(layout, collision, l, isUserAction, compactType, cols);\n    } else {\n      layout = moveElementAwayFromCollision(layout, l, collision, isUserAction, compactType, cols);\n    }\n  }\n\n  return layout;\n}\n/**\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\n * We attempt to move it up if there's room, otherwise it goes below.\n *\n * @param  {Array} layout            Full layout to modify.\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\n */\n\n\nfunction moveElementAwayFromCollision(layout\n/*: Layout*/\n, collidesWith\n/*: LayoutItem*/\n, itemToMove\n/*: LayoutItem*/\n, isUserAction\n/*: ?boolean*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n)\n/*: Layout*/\n{\n  var compactH = compactType === \"horizontal\"; // Compact vertically if not set to horizontal\n\n  var compactV = compactType !== \"horizontal\";\n  var preventCollision = collidesWith.static; // we're already colliding (not for static items)\n  // If there is enough space above the collision to put this element, move it there.\n  // We only do this on the main collision as this can get funky in cascades and cause\n  // unwanted swapping behavior.\n\n  if (isUserAction) {\n    // Reset isUserAction flag because we're not in the main collision anymore.\n    isUserAction = false; // Make a mock item so we don't modify the item here, only modify in moveElement.\n\n    var fakeItem\n    /*: LayoutItem*/\n    = {\n      x: compactH ? Math.max(collidesWith.x - itemToMove.w, 0) : itemToMove.x,\n      y: compactV ? Math.max(collidesWith.y - itemToMove.h, 0) : itemToMove.y,\n      w: itemToMove.w,\n      h: itemToMove.h,\n      i: \"-1\"\n    }; // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal\n\n    if (!getFirstCollision(layout, fakeItem)) {\n      log(\"Doing reverse collision on \".concat(itemToMove.i, \" up to [\").concat(fakeItem.x, \",\").concat(fakeItem.y, \"].\"));\n      return moveElement(layout, itemToMove, compactH ? fakeItem.x : undefined, compactV ? fakeItem.y : undefined, isUserAction, preventCollision, compactType, cols);\n    }\n  }\n\n  return moveElement(layout, itemToMove, compactH ? itemToMove.x + 1 : undefined, compactV ? itemToMove.y + 1 : undefined, isUserAction, preventCollision, compactType, cols);\n}\n/**\n * Helper to convert a number to a percentage string.\n *\n * @param  {Number} num Any number\n * @return {String}     That number as a percentage.\n */\n\n\nfunction perc(num\n/*: number*/\n)\n/*: string*/\n{\n  return num * 100 + \"%\";\n}\n\nfunction setTransform(_ref)\n/*: Object*/\n{\n  var top = _ref.top,\n      left = _ref.left,\n      width = _ref.width,\n      height = _ref.height; // Replace unitless items with px\n\n  var translate = \"translate(\".concat(left, \"px,\").concat(top, \"px)\");\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: \"\".concat(width, \"px\"),\n    height: \"\".concat(height, \"px\"),\n    position: \"absolute\"\n  };\n}\n\nfunction setTopLeft(_ref2)\n/*: Object*/\n{\n  var top = _ref2.top,\n      left = _ref2.left,\n      width = _ref2.width,\n      height = _ref2.height;\n  return {\n    top: \"\".concat(top, \"px\"),\n    left: \"\".concat(left, \"px\"),\n    width: \"\".concat(width, \"px\"),\n    height: \"\".concat(height, \"px\"),\n    position: \"absolute\"\n  };\n}\n/**\n * Get layout items sorted from top left to right and down.\n *\n * @return {Array} Array of layout objects.\n * @return {Array}        Layout, sorted static items first.\n */\n\n\nfunction sortLayoutItems(layout\n/*: Layout*/\n, compactType\n/*: CompactType*/\n)\n/*: Layout*/\n{\n  if (compactType === \"horizontal\") return sortLayoutItemsByColRow(layout);\n  if (compactType === \"vertical\") return sortLayoutItemsByRowCol(layout);else return layout;\n}\n/**\n * Sort layout items by row ascending and column ascending.\n *\n * Does not modify Layout.\n */\n\n\nfunction sortLayoutItemsByRowCol(layout\n/*: Layout*/\n)\n/*: Layout*/\n{\n  // Slice to clone array as sort modifies\n  return layout.slice(0).sort(function (a, b) {\n    if (a.y > b.y || a.y === b.y && a.x > b.x) {\n      return 1;\n    } else if (a.y === b.y && a.x === b.x) {\n      // Without this, we can get different sort results in IE vs. Chrome/FF\n      return 0;\n    }\n\n    return -1;\n  });\n}\n/**\n * Sort layout items by column ascending then row ascending.\n *\n * Does not modify Layout.\n */\n\n\nfunction sortLayoutItemsByColRow(layout\n/*: Layout*/\n)\n/*: Layout*/\n{\n  return layout.slice(0).sort(function (a, b) {\n    if (a.x > b.x || a.x === b.x && a.y > b.y) {\n      return 1;\n    }\n\n    return -1;\n  });\n}\n/**\n * Generate a layout using the initialLayout and children as a template.\n * Missing entries will be added, extraneous ones will be truncated.\n *\n * Does not modify initialLayout.\n *\n * @param  {Array}  initialLayout Layout passed in through props.\n * @param  {String} breakpoint    Current responsive breakpoint.\n * @param  {?String} compact      Compaction option.\n * @return {Array}                Working layout.\n */\n\n\nfunction synchronizeLayoutWithChildren(initialLayout\n/*: Layout*/\n, children\n/*: ReactChildren*/\n, cols\n/*: number*/\n, compactType\n/*: CompactType*/\n, allowOverlap\n/*: ?boolean*/\n)\n/*: Layout*/\n{\n  initialLayout = initialLayout || []; // Generate one layout item per child.\n\n  var layout\n  /*: LayoutItem[]*/\n  = [];\n\n  _react.default.Children.forEach(children, function (child\n  /*: ReactElement<any>*/\n  ) {\n    // Child may not exist\n    if ((child === null || child === void 0 ? void 0 : child.key) == null) return; // Don't overwrite if it already exists.\n\n    var exists = getLayoutItem(initialLayout, String(child.key));\n\n    if (exists) {\n      layout.push(cloneLayoutItem(exists));\n    } else {\n      if (!isProduction && child.props._grid) {\n        console.warn(\"`_grid` properties on children have been deprecated as of React 15.2. \" + \"Please use `data-grid` or add your properties directly to the `layout`.\");\n      }\n\n      var g = child.props[\"data-grid\"] || child.props._grid; // Hey, this item has a data-grid property, use it.\n\n      if (g) {\n        if (!isProduction) {\n          validateLayout([g], \"ReactGridLayout.children\");\n        } // FIXME clone not really necessary here\n\n\n        layout.push(cloneLayoutItem(_objectSpread(_objectSpread({}, g), {}, {\n          i: child.key\n        })));\n      } else {\n        // Nothing provided: ensure this is added to the bottom\n        // FIXME clone not really necessary here\n        layout.push(cloneLayoutItem({\n          w: 1,\n          h: 1,\n          x: 0,\n          y: bottom(layout),\n          i: String(child.key)\n        }));\n      }\n    }\n  }); // Correct the layout.\n\n\n  var correctedLayout = correctBounds(layout, {\n    cols: cols\n  });\n  return allowOverlap ? correctedLayout : compact(correctedLayout, compactType, cols);\n}\n/**\n * Validate a layout. Throws errors.\n *\n * @param  {Array}  layout        Array of layout items.\n * @param  {String} [contextName] Context name for errors.\n * @throw  {Error}                Validation error.\n */\n\n\nfunction validateLayout(layout\n/*: Layout*/\n)\n/*: void*/\n{\n  var contextName\n  /*: string*/\n  = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Layout\";\n  var subProps = [\"x\", \"y\", \"w\", \"h\"];\n  if (!Array.isArray(layout)) throw new Error(contextName + \" must be an array!\");\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    var item = layout[i];\n\n    for (var j = 0; j < subProps.length; j++) {\n      if (typeof item[subProps[j]] !== \"number\") {\n        throw new Error(\"ReactGridLayout: \" + contextName + \"[\" + i + \"].\" + subProps[j] + \" must be a number!\");\n      }\n    }\n  }\n} // Legacy support for verticalCompact: false\n\n\nfunction compactType(props\n/*: ?{ verticalCompact: boolean, compactType: CompactType }*/\n)\n/*: CompactType*/\n{\n  var _ref3 = props || {},\n      verticalCompact = _ref3.verticalCompact,\n      compactType = _ref3.compactType;\n\n  return verticalCompact === false ? null : compactType;\n}\n\nfunction log() {\n  var _console;\n\n  if (!DEBUG) return; // eslint-disable-next-line no-console\n\n  (_console = console).log.apply(_console, arguments);\n}\n\nvar noop = function noop() {};\n\nexports.noop = noop;","map":{"version":3,"sources":["/Users/jakemartin/Documents/table-scanner-fullstack/frontend/node_modules/react-grid-layout/build/utils.js"],"names":["Object","defineProperty","exports","value","bottom","childrenEqual","cloneLayout","cloneLayoutItem","collides","compact","compactItem","compactType","correctBounds","fastPositionEqual","fastRGLPropsEqual","getAllCollisions","getFirstCollision","getLayoutItem","getStatics","modifyLayout","moveElement","moveElementAwayFromCollision","noop","perc","setTopLeft","setTransform","sortLayoutItems","sortLayoutItemsByColRow","sortLayoutItemsByRowCol","synchronizeLayoutWithChildren","validateLayout","withLayoutItem","_lodash","_interopRequireDefault","require","_react","obj","__esModule","default","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","configurable","writable","isProduction","process","env","NODE_ENV","DEBUG","layout","max","bottomY","len","y","h","newLayout","Array","layoutItem","itemKey","cb","item","w","x","minW","maxW","minH","maxH","moved","Boolean","static","isDraggable","isResizable","resizeHandles","isBounded","a","b","Children","map","c","left","top","width","height","l1","l2","cols","compareWith","sorted","out","l","indexOf","heightWidth","resolveCompactionCollision","moveToCoord","axis","sizeProp","itemIndex","otherItem","fullLayout","compactV","compactH","Math","min","bounds","collidesWith","id","isUserAction","preventCollision","allowOverlap","log","concat","String","oldX","oldY","movingUp","reverse","collisions","hasCollisions","collision","itemToMove","fakeItem","undefined","num","_ref","translate","transform","WebkitTransform","MozTransform","msTransform","OTransform","position","_ref2","slice","sort","initialLayout","children","child","exists","props","_grid","console","warn","g","correctedLayout","contextName","subProps","isArray","Error","j","_ref3","verticalCompact","_console"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bottom = bottom;\nexports.childrenEqual = childrenEqual;\nexports.cloneLayout = cloneLayout;\nexports.cloneLayoutItem = cloneLayoutItem;\nexports.collides = collides;\nexports.compact = compact;\nexports.compactItem = compactItem;\nexports.compactType = compactType;\nexports.correctBounds = correctBounds;\nexports.fastPositionEqual = fastPositionEqual;\nexports.fastRGLPropsEqual = void 0;\nexports.getAllCollisions = getAllCollisions;\nexports.getFirstCollision = getFirstCollision;\nexports.getLayoutItem = getLayoutItem;\nexports.getStatics = getStatics;\nexports.modifyLayout = modifyLayout;\nexports.moveElement = moveElement;\nexports.moveElementAwayFromCollision = moveElementAwayFromCollision;\nexports.noop = void 0;\nexports.perc = perc;\nexports.setTopLeft = setTopLeft;\nexports.setTransform = setTransform;\nexports.sortLayoutItems = sortLayoutItems;\nexports.sortLayoutItemsByColRow = sortLayoutItemsByColRow;\nexports.sortLayoutItemsByRowCol = sortLayoutItemsByRowCol;\nexports.synchronizeLayoutWithChildren = synchronizeLayoutWithChildren;\nexports.validateLayout = validateLayout;\nexports.withLayoutItem = withLayoutItem;\n\nvar _lodash = _interopRequireDefault(require(\"lodash.isequal\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar isProduction = process.env.NODE_ENV === \"production\";\nvar DEBUG = false;\n/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\n\nfunction bottom(layout\n/*: Layout*/\n)\n/*: number*/\n{\n  var max = 0,\n      bottomY;\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    bottomY = layout[i].y + layout[i].h;\n    if (bottomY > max) max = bottomY;\n  }\n\n  return max;\n}\n\nfunction cloneLayout(layout\n/*: Layout*/\n)\n/*: Layout*/\n{\n  var newLayout = Array(layout.length);\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    newLayout[i] = cloneLayoutItem(layout[i]);\n  }\n\n  return newLayout;\n} // Modify a layoutItem inside a layout. Returns a new Layout,\n// does not mutate. Carries over all other LayoutItems unmodified.\n\n\nfunction modifyLayout(layout\n/*: Layout*/\n, layoutItem\n/*: LayoutItem*/\n)\n/*: Layout*/\n{\n  var newLayout = Array(layout.length);\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (layoutItem.i === layout[i].i) {\n      newLayout[i] = layoutItem;\n    } else {\n      newLayout[i] = layout[i];\n    }\n  }\n\n  return newLayout;\n} // Function to be called to modify a layout item.\n// Does defensive clones to ensure the layout is not modified.\n\n\nfunction withLayoutItem(layout\n/*: Layout*/\n, itemKey\n/*: string*/\n, cb\n/*: LayoutItem => LayoutItem*/\n)\n/*: [Layout, ?LayoutItem]*/\n{\n  var item = getLayoutItem(layout, itemKey);\n  if (!item) return [layout, null];\n  item = cb(cloneLayoutItem(item)); // defensive clone then modify\n  // FIXME could do this faster if we already knew the index\n\n  layout = modifyLayout(layout, item);\n  return [layout, item];\n} // Fast path to cloning, since this is monomorphic\n\n\nfunction cloneLayoutItem(layoutItem\n/*: LayoutItem*/\n)\n/*: LayoutItem*/\n{\n  return {\n    w: layoutItem.w,\n    h: layoutItem.h,\n    x: layoutItem.x,\n    y: layoutItem.y,\n    i: layoutItem.i,\n    minW: layoutItem.minW,\n    maxW: layoutItem.maxW,\n    minH: layoutItem.minH,\n    maxH: layoutItem.maxH,\n    moved: Boolean(layoutItem.moved),\n    static: Boolean(layoutItem.static),\n    // These can be null/undefined\n    isDraggable: layoutItem.isDraggable,\n    isResizable: layoutItem.isResizable,\n    resizeHandles: layoutItem.resizeHandles,\n    isBounded: layoutItem.isBounded\n  };\n}\n/**\n * Comparing React `children` is a bit difficult. This is a good way to compare them.\n * This will catch differences in keys, order, and length.\n */\n\n\nfunction childrenEqual(a\n/*: ReactChildren*/\n, b\n/*: ReactChildren*/\n)\n/*: boolean*/\n{\n  return (0, _lodash.default)(_react.default.Children.map(a, function (c) {\n    return c === null || c === void 0 ? void 0 : c.key;\n  }), _react.default.Children.map(b, function (c) {\n    return c === null || c === void 0 ? void 0 : c.key;\n  }));\n}\n/**\n * See `fastRGLPropsEqual.js`.\n * We want this to run as fast as possible - it is called often - and to be\n * resilient to new props that we add. So rather than call lodash.isEqual,\n * which isn't suited to comparing props very well, we use this specialized\n * function in conjunction with preval to generate the fastest possible comparison\n * function, tuned for exactly our props.\n */\n\n/*:: type FastRGLPropsEqual = (Object, Object, Function) => boolean;*/\n\n\nvar fastRGLPropsEqual\n/*: FastRGLPropsEqual*/\n= require(\"./fastRGLPropsEqual\"); // Like the above, but a lot simpler.\n\n\nexports.fastRGLPropsEqual = fastRGLPropsEqual;\n\nfunction fastPositionEqual(a\n/*: Position*/\n, b\n/*: Position*/\n)\n/*: boolean*/\n{\n  return a.left === b.left && a.top === b.top && a.width === b.width && a.height === b.height;\n}\n/**\n * Given two layoutitems, check if they collide.\n */\n\n\nfunction collides(l1\n/*: LayoutItem*/\n, l2\n/*: LayoutItem*/\n)\n/*: boolean*/\n{\n  if (l1.i === l2.i) return false; // same element\n\n  if (l1.x + l1.w <= l2.x) return false; // l1 is left of l2\n\n  if (l1.x >= l2.x + l2.w) return false; // l1 is right of l2\n\n  if (l1.y + l1.h <= l2.y) return false; // l1 is above l2\n\n  if (l1.y >= l2.y + l2.h) return false; // l1 is below l2\n\n  return true; // boxes overlap\n}\n/**\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\n * between items.\n *\n * Does not modify layout items (clones). Creates a new layout array.\n *\n * @param  {Array} layout Layout.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return {Array}       Compacted Layout.\n */\n\n\nfunction compact(layout\n/*: Layout*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n)\n/*: Layout*/\n{\n  // Statics go in the compareWith array right away so items flow around them.\n  var compareWith = getStatics(layout); // We go through the items by row and column.\n\n  var sorted = sortLayoutItems(layout, compactType); // Holding for new items.\n\n  var out = Array(layout.length);\n\n  for (var i = 0, len = sorted.length; i < len; i++) {\n    var l = cloneLayoutItem(sorted[i]); // Don't move static elements\n\n    if (!l.static) {\n      l = compactItem(compareWith, l, compactType, cols, sorted); // Add to comparison array. We only collide with items before this one.\n      // Statics are already in this array.\n\n      compareWith.push(l);\n    } // Add to output array to make sure they still come out in the right order.\n\n\n    out[layout.indexOf(sorted[i])] = l; // Clear moved flag, if it exists.\n\n    l.moved = false;\n  }\n\n  return out;\n}\n\nvar heightWidth = {\n  x: \"w\",\n  y: \"h\"\n};\n/**\n * Before moving item down, it will check if the movement will cause collisions and move those items down before.\n */\n\nfunction resolveCompactionCollision(layout\n/*: Layout*/\n, item\n/*: LayoutItem*/\n, moveToCoord\n/*: number*/\n, axis\n/*: \"x\" | \"y\"*/\n) {\n  var sizeProp = heightWidth[axis];\n  item[axis] += 1;\n  var itemIndex = layout.map(function (layoutItem) {\n    return layoutItem.i;\n  }).indexOf(item.i); // Go through each item we collide with.\n\n  for (var i = itemIndex + 1; i < layout.length; i++) {\n    var otherItem = layout[i]; // Ignore static items\n\n    if (otherItem.static) continue; // Optimization: we can break early if we know we're past this el\n    // We can do this b/c it's a sorted layout\n\n    if (otherItem.y > item.y + item.h) break;\n\n    if (collides(item, otherItem)) {\n      resolveCompactionCollision(layout, otherItem, moveToCoord + item[sizeProp], axis);\n    }\n  }\n\n  item[axis] = moveToCoord;\n}\n/**\n * Compact an item in the layout.\n *\n * Modifies item.\n *\n */\n\n\nfunction compactItem(compareWith\n/*: Layout*/\n, l\n/*: LayoutItem*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n, fullLayout\n/*: Layout*/\n)\n/*: LayoutItem*/\n{\n  var compactV = compactType === \"vertical\";\n  var compactH = compactType === \"horizontal\";\n\n  if (compactV) {\n    // Bottom 'y' possible is the bottom of the layout.\n    // This allows you to do nice stuff like specify {y: Infinity}\n    // This is here because the layout must be sorted in order to get the correct bottom `y`.\n    l.y = Math.min(bottom(compareWith), l.y); // Move the element up as far as it can go without colliding.\n\n    while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n      l.y--;\n    }\n  } else if (compactH) {\n    // Move the element left as far as it can go without colliding.\n    while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n      l.x--;\n    }\n  } // Move it down, and keep moving it down if it's colliding.\n\n\n  var collides;\n\n  while (collides = getFirstCollision(compareWith, l)) {\n    if (compactH) {\n      resolveCompactionCollision(fullLayout, l, collides.x + collides.w, \"x\");\n    } else {\n      resolveCompactionCollision(fullLayout, l, collides.y + collides.h, \"y\");\n    } // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.\n\n\n    if (compactH && l.x + l.w > cols) {\n      l.x = cols - l.w;\n      l.y++;\n    }\n  } // Ensure that there are no negative positions\n\n\n  l.y = Math.max(l.y, 0);\n  l.x = Math.max(l.x, 0);\n  return l;\n}\n/**\n * Given a layout, make sure all elements fit within its bounds.\n *\n * Modifies layout items.\n *\n * @param  {Array} layout Layout array.\n * @param  {Number} bounds Number of columns.\n */\n\n\nfunction correctBounds(layout\n/*: Layout*/\n, bounds\n/*: { cols: number }*/\n)\n/*: Layout*/\n{\n  var collidesWith = getStatics(layout);\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    var l = layout[i]; // Overflows right\n\n    if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w; // Overflows left\n\n    if (l.x < 0) {\n      l.x = 0;\n      l.w = bounds.cols;\n    }\n\n    if (!l.static) collidesWith.push(l);else {\n      // If this is static and collides with other statics, we must move it down.\n      // We have to do something nicer than just letting them overlap.\n      while (getFirstCollision(collidesWith, l)) {\n        l.y++;\n      }\n    }\n  }\n\n  return layout;\n}\n/**\n * Get a layout item by ID. Used so we can override later on if necessary.\n *\n * @param  {Array}  layout Layout array.\n * @param  {String} id     ID\n * @return {LayoutItem}    Item at ID.\n */\n\n\nfunction getLayoutItem(layout\n/*: Layout*/\n, id\n/*: string*/\n)\n/*: ?LayoutItem*/\n{\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (layout[i].i === id) return layout[i];\n  }\n}\n/**\n * Returns the first item this layout collides with.\n * It doesn't appear to matter which order we approach this from, although\n * perhaps that is the wrong thing to do.\n *\n * @param  {Object} layoutItem Layout item.\n * @return {Object|undefined}  A colliding layout item, or undefined.\n */\n\n\nfunction getFirstCollision(layout\n/*: Layout*/\n, layoutItem\n/*: LayoutItem*/\n)\n/*: ?LayoutItem*/\n{\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (collides(layout[i], layoutItem)) return layout[i];\n  }\n}\n\nfunction getAllCollisions(layout\n/*: Layout*/\n, layoutItem\n/*: LayoutItem*/\n)\n/*: Array<LayoutItem>*/\n{\n  return layout.filter(function (l) {\n    return collides(l, layoutItem);\n  });\n}\n/**\n * Get all static elements.\n * @param  {Array} layout Array of layout objects.\n * @return {Array}        Array of static layout items..\n */\n\n\nfunction getStatics(layout\n/*: Layout*/\n)\n/*: Array<LayoutItem>*/\n{\n  return layout.filter(function (l) {\n    return l.static;\n  });\n}\n/**\n * Move an element. Responsible for doing cascading movements of other elements.\n *\n * Modifies layout items.\n *\n * @param  {Array}      layout            Full layout to modify.\n * @param  {LayoutItem} l                 element to move.\n * @param  {Number}     [x]               X position in grid units.\n * @param  {Number}     [y]               Y position in grid units.\n */\n\n\nfunction moveElement(layout\n/*: Layout*/\n, l\n/*: LayoutItem*/\n, x\n/*: ?number*/\n, y\n/*: ?number*/\n, isUserAction\n/*: ?boolean*/\n, preventCollision\n/*: ?boolean*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n, allowOverlap\n/*: ?boolean*/\n)\n/*: Layout*/\n{\n  // If this is static and not explicitly enabled as draggable,\n  // no move is possible, so we can short-circuit this immediately.\n  if (l.static && l.isDraggable !== true) return layout; // Short-circuit if nothing to do.\n\n  if (l.y === y && l.x === x) return layout;\n  log(\"Moving element \".concat(l.i, \" to [\").concat(String(x), \",\").concat(String(y), \"] from [\").concat(l.x, \",\").concat(l.y, \"]\"));\n  var oldX = l.x;\n  var oldY = l.y; // This is quite a bit faster than extending the object\n\n  if (typeof x === \"number\") l.x = x;\n  if (typeof y === \"number\") l.y = y;\n  l.moved = true; // If this collides with anything, move it.\n  // When doing this comparison, we have to sort the items we compare with\n  // to ensure, in the case of multiple collisions, that we're getting the\n  // nearest collision.\n\n  var sorted = sortLayoutItems(layout, compactType);\n  var movingUp = compactType === \"vertical\" && typeof y === \"number\" ? oldY >= y : compactType === \"horizontal\" && typeof x === \"number\" ? oldX >= x : false; // $FlowIgnore acceptable modification of read-only array as it was recently cloned\n\n  if (movingUp) sorted = sorted.reverse();\n  var collisions = getAllCollisions(sorted, l);\n  var hasCollisions = collisions.length > 0; // We may have collisions. We can short-circuit if we've turned off collisions or\n  // allowed overlap.\n\n  if (hasCollisions && allowOverlap) {\n    // Easy, we don't need to resolve collisions. But we *did* change the layout,\n    // so clone it on the way out.\n    return cloneLayout(layout);\n  } else if (hasCollisions && preventCollision) {\n    // If we are preventing collision but not allowing overlap, we need to\n    // revert the position of this element so it goes to where it came from, rather\n    // than the user's desired location.\n    log(\"Collision prevented on \".concat(l.i, \", reverting.\"));\n    l.x = oldX;\n    l.y = oldY;\n    l.moved = false;\n    return layout; // did not change so don't clone\n  } // Move each item that collides away from this element.\n\n\n  for (var i = 0, len = collisions.length; i < len; i++) {\n    var collision = collisions[i];\n    log(\"Resolving collision between \".concat(l.i, \" at [\").concat(l.x, \",\").concat(l.y, \"] and \").concat(collision.i, \" at [\").concat(collision.x, \",\").concat(collision.y, \"]\")); // Short circuit so we can't infinite loop\n\n    if (collision.moved) continue; // Don't move static items - we have to move *this* element away\n\n    if (collision.static) {\n      layout = moveElementAwayFromCollision(layout, collision, l, isUserAction, compactType, cols);\n    } else {\n      layout = moveElementAwayFromCollision(layout, l, collision, isUserAction, compactType, cols);\n    }\n  }\n\n  return layout;\n}\n/**\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\n * We attempt to move it up if there's room, otherwise it goes below.\n *\n * @param  {Array} layout            Full layout to modify.\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\n */\n\n\nfunction moveElementAwayFromCollision(layout\n/*: Layout*/\n, collidesWith\n/*: LayoutItem*/\n, itemToMove\n/*: LayoutItem*/\n, isUserAction\n/*: ?boolean*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n)\n/*: Layout*/\n{\n  var compactH = compactType === \"horizontal\"; // Compact vertically if not set to horizontal\n\n  var compactV = compactType !== \"horizontal\";\n  var preventCollision = collidesWith.static; // we're already colliding (not for static items)\n  // If there is enough space above the collision to put this element, move it there.\n  // We only do this on the main collision as this can get funky in cascades and cause\n  // unwanted swapping behavior.\n\n  if (isUserAction) {\n    // Reset isUserAction flag because we're not in the main collision anymore.\n    isUserAction = false; // Make a mock item so we don't modify the item here, only modify in moveElement.\n\n    var fakeItem\n    /*: LayoutItem*/\n    = {\n      x: compactH ? Math.max(collidesWith.x - itemToMove.w, 0) : itemToMove.x,\n      y: compactV ? Math.max(collidesWith.y - itemToMove.h, 0) : itemToMove.y,\n      w: itemToMove.w,\n      h: itemToMove.h,\n      i: \"-1\"\n    }; // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal\n\n    if (!getFirstCollision(layout, fakeItem)) {\n      log(\"Doing reverse collision on \".concat(itemToMove.i, \" up to [\").concat(fakeItem.x, \",\").concat(fakeItem.y, \"].\"));\n      return moveElement(layout, itemToMove, compactH ? fakeItem.x : undefined, compactV ? fakeItem.y : undefined, isUserAction, preventCollision, compactType, cols);\n    }\n  }\n\n  return moveElement(layout, itemToMove, compactH ? itemToMove.x + 1 : undefined, compactV ? itemToMove.y + 1 : undefined, isUserAction, preventCollision, compactType, cols);\n}\n/**\n * Helper to convert a number to a percentage string.\n *\n * @param  {Number} num Any number\n * @return {String}     That number as a percentage.\n */\n\n\nfunction perc(num\n/*: number*/\n)\n/*: string*/\n{\n  return num * 100 + \"%\";\n}\n\nfunction setTransform(_ref)\n/*: Object*/\n{\n  var top = _ref.top,\n      left = _ref.left,\n      width = _ref.width,\n      height = _ref.height;\n  // Replace unitless items with px\n  var translate = \"translate(\".concat(left, \"px,\").concat(top, \"px)\");\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: \"\".concat(width, \"px\"),\n    height: \"\".concat(height, \"px\"),\n    position: \"absolute\"\n  };\n}\n\nfunction setTopLeft(_ref2)\n/*: Object*/\n{\n  var top = _ref2.top,\n      left = _ref2.left,\n      width = _ref2.width,\n      height = _ref2.height;\n  return {\n    top: \"\".concat(top, \"px\"),\n    left: \"\".concat(left, \"px\"),\n    width: \"\".concat(width, \"px\"),\n    height: \"\".concat(height, \"px\"),\n    position: \"absolute\"\n  };\n}\n/**\n * Get layout items sorted from top left to right and down.\n *\n * @return {Array} Array of layout objects.\n * @return {Array}        Layout, sorted static items first.\n */\n\n\nfunction sortLayoutItems(layout\n/*: Layout*/\n, compactType\n/*: CompactType*/\n)\n/*: Layout*/\n{\n  if (compactType === \"horizontal\") return sortLayoutItemsByColRow(layout);\n  if (compactType === \"vertical\") return sortLayoutItemsByRowCol(layout);else return layout;\n}\n/**\n * Sort layout items by row ascending and column ascending.\n *\n * Does not modify Layout.\n */\n\n\nfunction sortLayoutItemsByRowCol(layout\n/*: Layout*/\n)\n/*: Layout*/\n{\n  // Slice to clone array as sort modifies\n  return layout.slice(0).sort(function (a, b) {\n    if (a.y > b.y || a.y === b.y && a.x > b.x) {\n      return 1;\n    } else if (a.y === b.y && a.x === b.x) {\n      // Without this, we can get different sort results in IE vs. Chrome/FF\n      return 0;\n    }\n\n    return -1;\n  });\n}\n/**\n * Sort layout items by column ascending then row ascending.\n *\n * Does not modify Layout.\n */\n\n\nfunction sortLayoutItemsByColRow(layout\n/*: Layout*/\n)\n/*: Layout*/\n{\n  return layout.slice(0).sort(function (a, b) {\n    if (a.x > b.x || a.x === b.x && a.y > b.y) {\n      return 1;\n    }\n\n    return -1;\n  });\n}\n/**\n * Generate a layout using the initialLayout and children as a template.\n * Missing entries will be added, extraneous ones will be truncated.\n *\n * Does not modify initialLayout.\n *\n * @param  {Array}  initialLayout Layout passed in through props.\n * @param  {String} breakpoint    Current responsive breakpoint.\n * @param  {?String} compact      Compaction option.\n * @return {Array}                Working layout.\n */\n\n\nfunction synchronizeLayoutWithChildren(initialLayout\n/*: Layout*/\n, children\n/*: ReactChildren*/\n, cols\n/*: number*/\n, compactType\n/*: CompactType*/\n, allowOverlap\n/*: ?boolean*/\n)\n/*: Layout*/\n{\n  initialLayout = initialLayout || []; // Generate one layout item per child.\n\n  var layout\n  /*: LayoutItem[]*/\n  = [];\n\n  _react.default.Children.forEach(children, function (child\n  /*: ReactElement<any>*/\n  ) {\n    // Child may not exist\n    if ((child === null || child === void 0 ? void 0 : child.key) == null) return; // Don't overwrite if it already exists.\n\n    var exists = getLayoutItem(initialLayout, String(child.key));\n\n    if (exists) {\n      layout.push(cloneLayoutItem(exists));\n    } else {\n      if (!isProduction && child.props._grid) {\n        console.warn(\"`_grid` properties on children have been deprecated as of React 15.2. \" + \"Please use `data-grid` or add your properties directly to the `layout`.\");\n      }\n\n      var g = child.props[\"data-grid\"] || child.props._grid; // Hey, this item has a data-grid property, use it.\n\n      if (g) {\n        if (!isProduction) {\n          validateLayout([g], \"ReactGridLayout.children\");\n        } // FIXME clone not really necessary here\n\n\n        layout.push(cloneLayoutItem(_objectSpread(_objectSpread({}, g), {}, {\n          i: child.key\n        })));\n      } else {\n        // Nothing provided: ensure this is added to the bottom\n        // FIXME clone not really necessary here\n        layout.push(cloneLayoutItem({\n          w: 1,\n          h: 1,\n          x: 0,\n          y: bottom(layout),\n          i: String(child.key)\n        }));\n      }\n    }\n  }); // Correct the layout.\n\n\n  var correctedLayout = correctBounds(layout, {\n    cols: cols\n  });\n  return allowOverlap ? correctedLayout : compact(correctedLayout, compactType, cols);\n}\n/**\n * Validate a layout. Throws errors.\n *\n * @param  {Array}  layout        Array of layout items.\n * @param  {String} [contextName] Context name for errors.\n * @throw  {Error}                Validation error.\n */\n\n\nfunction validateLayout(layout\n/*: Layout*/\n)\n/*: void*/\n{\n  var contextName\n  /*: string*/\n  = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Layout\";\n  var subProps = [\"x\", \"y\", \"w\", \"h\"];\n  if (!Array.isArray(layout)) throw new Error(contextName + \" must be an array!\");\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    var item = layout[i];\n\n    for (var j = 0; j < subProps.length; j++) {\n      if (typeof item[subProps[j]] !== \"number\") {\n        throw new Error(\"ReactGridLayout: \" + contextName + \"[\" + i + \"].\" + subProps[j] + \" must be a number!\");\n      }\n    }\n  }\n} // Legacy support for verticalCompact: false\n\n\nfunction compactType(props\n/*: ?{ verticalCompact: boolean, compactType: CompactType }*/\n)\n/*: CompactType*/\n{\n  var _ref3 = props || {},\n      verticalCompact = _ref3.verticalCompact,\n      compactType = _ref3.compactType;\n\n  return verticalCompact === false ? null : compactType;\n}\n\nfunction log() {\n  var _console;\n\n  if (!DEBUG) return; // eslint-disable-next-line no-console\n\n  (_console = console).log.apply(_console, arguments);\n}\n\nvar noop = function noop() {};\n\nexports.noop = noop;"]},"metadata":{},"sourceType":"script"}